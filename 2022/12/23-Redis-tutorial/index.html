<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/images/logo.png"><link rel="icon" href="/images/logo.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Jas0n0ss"><meta name="keywords" content="oss"><meta name="description" content="Redis tutorial"><meta property="og:type" content="article"><meta property="og:title" content="Redis tutorial"><meta property="og:url" content="https://git.msft.vip/2022/12/23-Redis-tutorial/index.html"><meta property="og:site_name" content="git.msft.vip"><meta property="og:description" content="Redis tutorial"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://git.msft.vip/images/1579599270964.png"><meta property="og:image" content="https://git.msft.vip/images/1579599297542.png"><meta property="og:image" content="https://git.msft.vip/images/1579600777968.png"><meta property="og:image" content="https://git.msft.vip/images/1579600848611.png"><meta property="article:published_time" content="2022-12-23T10:03:52.000Z"><meta property="article:modified_time" content="2024-08-09T12:13:50.165Z"><meta property="article:author" content="Jas0n0ss"><meta property="article:tag" content="redis"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://git.msft.vip/images/1579599270964.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>Redis tutorial - git.msft.vip</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom_icon/other/iconfont.css"><link rel="stylesheet" href="/css/custom_icon/phone/iconfont.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"git.msft.vip",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Jas0n0ss</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-shouye"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives"><i class="iconfont icon-guidang"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/tags"><i class="iconfont icon-biaoqian"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/video"><i class="iconfont icon-youtube"></i> <span>视频</span></a></li><li class="nav-item"><a class="nav-link" href="/music"><i class="iconfont icon-tubiaozhizuomobanyihuifu-"></i> <span>音乐</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/code.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Redis tutorial"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Jas0n0ss </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-12-23 18:03" pubdate>2022年12月23日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 61 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Redis tutorial</h1><p class="note note-info">本文最后更新于：2024年8月9日 晚上</p><div class="markdown-body"><p>Redis 是高性能 NoSQL 内存 key-value 数据库，支持数据的持久化、备份、事物、发布&#x2F;订阅、通知、key 过期等特性。</p><p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1 数据类型"></a>1 数据类型</h3><p>Redis支持五种数据类型：</p><ul><li><strong>String</strong><br>最基本类型，类似Memcached，二进制安全。一个键最大存储512MB</li><li><strong>Hash</strong><br>string类型的映射表，特别适合存储对象。每个 hash 可以存储 2^32-1 键值对。</li><li><strong>List</strong><br>string类型的列表，按照插入顺序排序。最多可存2^32-1元素。</li><li><strong>Set</strong><br>string类型的无序集合，通过哈希表实现，成员元素唯一。最大的成员数为 2^32-1。</li><li><strong>zset</strong><br>string类型的有序集合，成员元素唯一。每个元素关联一个double类型的分数。通过分数排序。</li></ul><h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h3><h4 id="2-1-字典"><a href="#2-1-字典" class="headerlink" title="2.1 字典"></a>2.1 字典</h4><h5 id="1）dictht"><a href="#1）dictht" class="headerlink" title="1）dictht"></a>1）dictht</h5><p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    dictEntry **table;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;<br>&#125; dictht;<br></code></pre></td></tr></table></figure><h5 id="2）dictEntry"><a href="#2）dictEntry" class="headerlink" title="2）dictEntry"></a>2）dictEntry</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-type">void</span> *key;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;<br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>        <span class="hljs-type">double</span> d;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure><h5 id="3）dict"><a href="#3）dict" class="headerlink" title="3）dict"></a>3）dict</h5><p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    dictType *type;<br>    <span class="hljs-type">void</span> *privdata;<br>    dictht ht[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">long</span> rehashidx; <span class="hljs-comment">/* rehashing not in progress if rehashidx == -1 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators; <span class="hljs-comment">/* number of iterators currently running */</span><br>&#125; dict;<br></code></pre></td></tr></table></figure><h5 id="4）rehash"><a href="#4）rehash" class="headerlink" title="4）rehash"></a>4）rehash</h5><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p><p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p><p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p><p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dictRehash</span><span class="hljs-params">(dict *d, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> empty_visits = n * <span class="hljs-number">10</span>; <span class="hljs-comment">/* Max number of empty buckets to visit. */</span><br>    <span class="hljs-keyword">if</span> (!dictIsRehashing(d)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="hljs-number">0</span>].used != <span class="hljs-number">0</span>) &#123;<br>        dictEntry *de, *nextde;<br><br>        <span class="hljs-comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span><br><span class="hljs-comment">         * elements because ht[0].used != 0 */</span><br>        assert(d-&gt;ht[<span class="hljs-number">0</span>].size &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) d-&gt;rehashidx);<br>        <span class="hljs-keyword">while</span> (d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] == <span class="hljs-literal">NULL</span>) &#123;<br>            d-&gt;rehashidx++;<br>            <span class="hljs-keyword">if</span> (--empty_visits == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        de = d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx];<br>        <span class="hljs-comment">/* Move all the keys in this bucket from the old to the new hash HT */</span><br>        <span class="hljs-keyword">while</span> (de) &#123;<br>            <span class="hljs-type">uint64_t</span> h;<br><br>            nextde = de-&gt;next;<br>            <span class="hljs-comment">/* Get the index in the new hash table */</span><br>            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="hljs-number">1</span>].sizemask;<br>            de-&gt;next = d-&gt;ht[<span class="hljs-number">1</span>].table[h];<br>            d-&gt;ht[<span class="hljs-number">1</span>].table[h] = de;<br>            d-&gt;ht[<span class="hljs-number">0</span>].used--;<br>            d-&gt;ht[<span class="hljs-number">1</span>].used++;<br>            de = nextde;<br>        &#125;<br>        d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] = <span class="hljs-literal">NULL</span>;<br>        d-&gt;rehashidx++;<br>    &#125;<br><br>    <span class="hljs-comment">/* Check if we already rehashed the whole table... */</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used == <span class="hljs-number">0</span>) &#123;<br>        zfree(d-&gt;ht[<span class="hljs-number">0</span>].table);<br>        d-&gt;ht[<span class="hljs-number">0</span>] = d-&gt;ht[<span class="hljs-number">1</span>];<br>        _dictReset(&amp;d-&gt;ht[<span class="hljs-number">1</span>]);<br>        d-&gt;rehashidx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* More to rehash... */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-跳跃表"><a href="#2-2-跳跃表" class="headerlink" title="2.2 跳跃表"></a>2.2 跳跃表</h4><p>是有序集合的底层实现之一。</p><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/wujun234/images@master/1579599270964.png"><img src="/../images/1579599270964.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/wujun234/images@master/1579599297542.png"><img src="/../images/1579599297542.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现；</li><li>支持无锁操作。</li></ul><h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3 使用场景"></a>3 使用场景</h3><h4 id="3-1-计数器"><a href="#3-1-计数器" class="headerlink" title="3.1 计数器"></a>3.1 计数器</h4><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><h4 id="3-2-缓存"><a href="#3-2-缓存" class="headerlink" title="3.2 缓存"></a>3.2 缓存</h4><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><h4 id="3-3-查找表"><a href="#3-3-查找表" class="headerlink" title="3.3 查找表"></a>3.3 查找表</h4><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><h4 id="3-4-消息队列"><a href="#3-4-消息队列" class="headerlink" title="3.4 消息队列"></a>3.4 消息队列</h4><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h4 id="3-5-会话缓存"><a href="#3-5-会话缓存" class="headerlink" title="3.5 会话缓存"></a>3.5 会话缓存</h4><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h4 id="3-6-分布式锁实现"><a href="#3-6-分布式锁实现" class="headerlink" title="3.6 分布式锁实现"></a>3.6 分布式锁实现</h4><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h4 id="3-7-其它"><a href="#3-7-其它" class="headerlink" title="3.7 其它"></a>3.7 其它</h4><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h3 id="4-Redis-命令"><a href="#4-Redis-命令" class="headerlink" title="4 Redis 命令"></a>4 Redis 命令</h3><ul><li>redis-cli：启动客户端<br>-r：重复执行<br>-i : 每隔几秒执行一次<br>-x : 读取标准输入<br>-c：连接redis集群时使用<br>-a：加入redis密码<br>–slave：把客户端模拟成所连接redis节点的从节点，获得数据库更新信息<br>–latency：测试客户端到redis服务器的网络延迟<br>–stat：实时监控redis信息<br>–raw：返回格式化后的结果<br>–no-raw：返回原始格式</li><li>redis-cli -h host -p port -a password：连接远程 redis 服务</li><li>slowlog get：慢查询</li><li>info memory：内存信息</li></ul><h3 id="5-数据淘汰策略"><a href="#5-数据淘汰策略" class="headerlink" title="5 数据淘汰策略"></a>5 数据淘汰策略</h3><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中任意选择数据进行淘汰</td></tr><tr><td>noeviction</td><td>禁止驱逐数据</td></tr></tbody></table><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h3 id="6-持久化"><a href="#6-持久化" class="headerlink" title="6 持久化"></a>6 持久化</h3><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h4 id="1）RDB-持久化"><a href="#1）RDB-持久化" class="headerlink" title="1）RDB 持久化"></a>1）RDB 持久化</h4><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h4 id="2）AOF-持久化"><a href="#2）AOF-持久化" class="headerlink" title="2）AOF 持久化"></a>2）AOF 持久化</h4><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th align="center">选项</th><th align="center">同步频率</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">每个写命令都同步</td></tr><tr><td align="center">everysec</td><td align="center">每秒同步一次</td></tr><tr><td align="center">no</td><td align="center">让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h3 id="7-Redis-事务"><a href="#7-Redis-事务" class="headerlink" title="7 Redis 事务"></a>7 Redis 事务</h3><p><strong>Redis 事务不遵循 ACID，中间出错，后面继续执行</strong></p><ul><li>multi：开启事务</li><li>exec：提交事务</li><li>discard：回滚事务</li><li>watch：监听事务（乐观锁）</li></ul><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><h3 id="8-事件"><a href="#8-事件" class="headerlink" title="8 事件"></a>8 事件</h3><p>Redis 服务器是一个事件驱动程序。</p><h4 id="8-1-文件事件"><a href="#8-1-文件事件" class="headerlink" title="8.1 文件事件"></a>8.1 文件事件</h4><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I&#x2F;O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/wujun234/images@master/1579600777968.png"><img src="/../images/1579600777968.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><h4 id="8-2-时间事件"><a href="#8-2-时间事件" class="headerlink" title="8.2 时间事件"></a>8.2 时间事件</h4><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p><p>时间事件又分为：</p><ul><li>定时事件：是让一段程序在指定的时间之内执行一次；</li><li>周期性事件：是让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p><h4 id="8-3-事件的调度与执行"><a href="#8-3-事件的调度与执行" class="headerlink" title="8.3 事件的调度与执行"></a>8.3 事件的调度与执行</h4><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">aeProcessEvents</span>():<br>    <span class="hljs-comment"># 获取到达时间离当前时间最接近的时间事件</span><br>    time_event = aeSearchNearestTimer()<br>    <span class="hljs-comment"># 计算最接近的时间事件距离到达还有多少毫秒</span><br>    remaind_ms = time_event.when - unix_ts_now()<br>    <span class="hljs-comment"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span><br>    <span class="hljs-keyword">if</span> remaind_ms &lt; <span class="hljs-number">0</span>:<br>        remaind_ms = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 根据 remaind_ms 的值，创建 timeval</span><br>    timeval = create_timeval_with_ms(remaind_ms)<br>    <span class="hljs-comment"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span><br>    aeApiPoll(timeval)<br>    <span class="hljs-comment"># 处理所有已产生的文件事件</span><br>    procesFileEvents()<br>    <span class="hljs-comment"># 处理所有已到达的时间事件</span><br>    processTimeEvents()<br></code></pre></td></tr></table></figure><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 初始化服务器</span><br>    init_server()<br>    <span class="hljs-comment"># 一直处理事件，直到服务器关闭为止</span><br>    <span class="hljs-keyword">while</span> server_is_not_shutdown():<br>        aeProcessEvents()<br>    <span class="hljs-comment"># 服务器关闭，执行清理操作</span><br>    clean_server()<br></code></pre></td></tr></table></figure><p>从事件处理的角度来看，服务器运行流程如下：</p><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/wujun234/images@master/1579600848611.png"><img src="/../images/1579600848611.png" srcset="/img/loading.gif" lazyload alt="img"></a></p><h3 id="9-Redis-备份与恢复"><a href="#9-Redis-备份与恢复" class="headerlink" title="9 Redis 备份与恢复"></a>9 Redis 备份与恢复</h3><ul><li>备份：<br>SAVE 命令：在安装目录创建dump.rdb文件。<br>BGSAVE命令：后台执行SAVE 。<br>AOF：保存命令，文件名appendonly.aof。需redis.conf中开启配置</li><li>恢复：将备份文件移到安装目录并启动服务</li></ul><h3 id="10-Redis-主从分离"><a href="#10-Redis-主从分离" class="headerlink" title="10 Redis 主从分离"></a>10 Redis 主从分离</h3><ol><li>将 redis.conf 拷贝多份，并且创建多个目录，每个目录中都有自己的redis.conf 配置文件</li><li>配置启动Maste<br>修改端口、pidfile（启动redis 时linux 分配的pid 进程号）</li><li>配置启动Slave<br>修改端口号和pid 文件，配置文件中配置从服务“slaveof 127.0.0.1 6380”或“masterauth ”</li><li>设置读写分离<br>在主服务器中设置“slave-read-only yes”</li></ol><h3 id="11-Redis-哨兵"><a href="#11-Redis-哨兵" class="headerlink" title="11 Redis 哨兵"></a>11 Redis 哨兵</h3><p>Sentinel 系统可以监视任意多个主服务器，以其从服务器，在被监视的主服务器下线时，自动将下线主服务器的某个从服务器升级为新的主服务器。</p><ol><li>配置Sentinel<br>在sentinel.conf 配置文件中port属性设置sentinel 的端口</li><li>启动Sentinel<br>&#x2F;sentinel$ redis-sentinel sentinel.conf</li></ol><h3 id="12-Redis-Cluster"><a href="#12-Redis-Cluster" class="headerlink" title="12 Redis Cluster"></a>12 Redis Cluster</h3><p>redis3.0开始提供了redis的分布式集群模式，redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value，保存时将 key 大致均等地哈希映射到不同的节点</p><ol><li>集群中redis节点彼此互联，客户端连接集群中任一可用节点即可</li><li>集群中超过半数的节点检测失效时，节点fail</li></ol><h3 id="13-分片"><a href="#13-分片" class="headerlink" title="13 分片"></a>13 分片</h3><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… ，有不同的方式来选择一个指定的键存储在哪个实例中。</p><ul><li>最简单的方式是范围分片，例如用户 id 从 0<del>1000 的存储到实例 R0 中，用户 id 从 1001</del>2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li><li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h3 id="14-Redis-与-Memcached-的区别"><a href="#14-Redis-与-Memcached-的区别" class="headerlink" title="14 Redis 与 Memcached 的区别"></a>14 Redis 与 Memcached 的区别</h3><h4 id="1）数据类型"><a href="#1）数据类型" class="headerlink" title="1）数据类型"></a>1）数据类型</h4><ul><li>Memcached 仅支持字符串类型</li><li>Redis 支持五种不同的数据类型</li></ul><h4 id="2）数据持久化"><a href="#2）数据持久化" class="headerlink" title="2）数据持久化"></a>2）数据持久化</h4><ul><li>Memcached 不支持持久化。</li><li>Redis 支持两种持久化策略：RDB 快照和 AOF 日志</li></ul><h4 id="3）分布式"><a href="#3）分布式" class="headerlink" title="3）分布式"></a>3）分布式</h4><ul><li>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</li><li>Redis Cluster 实现了分布式的支持。</li></ul><h4 id="4）内存管理机制"><a href="#4）内存管理机制" class="headerlink" title="4）内存管理机制"></a>4）内存管理机制</h4><ul><li>Memcached 使用预分配的内存池，存在空间浪费<ul><li>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</li></ul></li><li>Redis 使用现场申请内存的方式，存在内存碎片<ul><li>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</li></ul></li></ul><h4 id="5）事务"><a href="#5）事务" class="headerlink" title="5）事务"></a>5）事务</h4><ul><li>Memcached 提供了 cas 命令</li><li>Redis 没有，只提供了事务</li></ul><h4 id="6）线程"><a href="#6）线程" class="headerlink" title="6）线程"></a>6）线程</h4><ul><li>Memcached 是多线程，非阻塞 IO 复用的网络模型</li><li>Redis 使用单线程的 IO 复用模型</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/linux/" class="category-chain-item">linux</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/redis/">#redis</a></div></div><div class="license-box my-3"><div class="license-title"><div>Redis tutorial</div><div>https://git.msft.vip/2022/12/23-Redis-tutorial/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Jas0n0ss</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年12月23日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年8月9日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/"><span class="hint--top hint--rounded" aria-label="ND - 禁止演绎"><i class="iconfont icon-nd"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/12/23-Offline-install-docker/" title="Offline install docker"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Offline install docker</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/12/23-prometheus-Tutorial/" title="Prometheus Tutorial"><span class="hidden-mobile">Prometheus Tutorial</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script>Fluid.utils.loadComments("#disqus_thread",(function(){Fluid.utils.createCssLink("https://cdn.staticfile.org/disqusjs/1.3.0/disqusjs.css"),Fluid.utils.createScript("https://cdn.staticfile.org/disqusjs/1.3.0/disqus.js",(function(){new DisqusJS({shortname:"fluid",apikey:""})}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></div></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Copyrights</span></a> <i class="iconfont icon-love"></i> <a href="https://git.msft.vip" target="_blank" rel="nofollow noopener"><span>Jas0n0ss</span></a></div></div></footer><script src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.staticfile.org/jquery/3.6.0/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://cdn.staticfile.org/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://cdn.staticfile.org/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://cdn.staticfile.org/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>